创建项目 vue3+ts
[toc]

# npm create vue@latest 开始构建
按提示输入项目名称、选择可选功能
启用：TypeScript, Router（单页面应用开发）, Pinia（状态管理）, ESLint（错误预防）
不启用：Prettier（代码格式化 垃圾）

ESLint 如果是ts js混用的话 不要启用 很恶心 得设置一堆配置

# 初始化
- npm install 安装依赖
- npm run dev 启动开发环境
- npm run build 编译正式环境

# 基础库安装
安装库后 有些库需要安装响应的类型库才能在ts中使用

## npm install axios api请求库安装

## npm install element-plus 安装elementUi
npm install @element-plus/icons-vue 安装类型库

## npm install nprogress 安装nprogress进度条

# main.ts 导入基础库
import ElementPlus from 'element-plus'  
import 'element-plus/dist/index.css'

app.use(ElementPlus)

# 安装SCSS
npm install sass -D

## src目录下新建目录styles 放置全局scss文件
例如 variables.scss

$bg-color:rgb(224, 242, 241)  //配置一个背景色

## vite.config.ts 文件中配置scss
export default defineConfig({
  css:{
    preprocessorOptions:{
        scss:{
            additionalData:`@use "@/styles/variables.scss" as *;`
        }
    }
  }
})

## View中使用
<style lang="scss" scoped>
   .main {
        background-color: $bg-color;
    }
</style>

# 配置文件
项目根目录下(src上级目录)新建配置文件(注意文件名起始是： 点 )：
  .env (所有环境 不新建该文件，使用下边两个即可)
  .env.development (开发环境)
  .env.production (生成环境)
  env.d.ts （项目初始化已创建了该文件, 需要加代码提供环境变量的ts类型提示）

- .env 文件是配置文件
VITE_ApiURL = 'https://localhost:7060'
VITE_SignatureKey = 'whoisyoudaddyjackasswhoisyoudaddyjackass'

- env.d.ts 
  为环境变量提供 TypeScript 类型提示，确保 TypeScript 能够识别这些环境变量的类型，但它本身不会向 import.meta.env 注入实际的值。
Vite构建项目所以必须以 VITE_开头
ts文件使用： import.meta.env.VITE_ApiURL

/// <reference types="vite/client" />
interface ImportMetaEnv {
  readonly VITE_ApiURL: 'https://localhost:7060';
  readonly VITE_SignatureKey: 'whoisyoudaddyjackasswhoisyoudaddyjackass';
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}


# 目录结构
- dist npm run build编译后目录
- node_modules npm加载的项目依赖模块
- src 开发目录
  - assets 放置一些图片，如logo等
  - components vue组件
  - router 路由
  - stores 状态管理
  - views 各个页面
  - App.vue 项目入口
  - main.js 项目核心文件
- utils 工具包
- public 公共资源目录
- package.json 项目配置文件
- README.md 项目说明文档
- 其他配置文件等
  - ts.config.json
  - vite.config.json
  - eslint.congi.json

# router/index.ts 配置路由
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
     {
      path: '/',
      redirect: '/login' //主页重定向到登录页
    },
    {
      path: '/home',
      name: 'home',
      component: HomeView,
      meta: { requiresAuth : true} //此页面需要认证登录,
      children: [//嵌套路由
        {
          path: 'resetPassword',
          name: 'resetPassword',
          component: () => import('@/views/ResetPassword.vue')
        }
      ]
    },
   {
      path: '/login',
      name: 'login',
      component: () => import('../views/LoginView.vue'),
    }
  ],
})

页面使用RouterLink配置导航
<RouterLink to="/home/resetPassword">resetPassword</RouterLink>
-- 打开新标签也加载 不加载到<RouterView />
<a href="/about" target="_blank">about</a>

## 路由守卫
//全局路由前置守卫 -> 未登录跳转到登录页面
配置路由 meta: { requiresAuth : true}

router.beforeEach((to, from, next) => {
  const userStore = UserStore()
  const isAuthenticated = userStore.GetIsLogin()
  if(to.matched.some(record => record.meta.requiresAuth) && !isAuthenticated)
  {
    next({name:'login'})
  }
  else
  {
    next()
  }
})

## 嵌套路由
- App.vue启动文件中的 <RouterView /> 加载最外层设置路由
- 例如这个页面也有一个  <RouterView /> 加载children中配置的路由
  {
      path: '/home',
      name: 'home',
      component: HomeView,
      meta: { requiresAuth : true} //此页面需要认证登录,
      children: [//嵌套路由
        {
          path: 'resetPassword', // /home/resetPassword
          name: 'resetPassword',
          component: () => import('@/views/ResetPassword.vue')
        }
      ]
    },

## 某页面单独打开标签页 直接<a>标签
<a href="/about" target="_blank">about</a>

# utils/request.ts 请求类
import axios from 'axios'
import type { AxiosResponse } from 'axios'

const axiosInstance = axios.create({  
    baseURL: 'https://localhost:7060',  
    timeout: 100000
})

//请求拦截器
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('sleet_config_token'); // 从本地存储获取 token
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    alert(error);
    return Promise.reject(error);
  }
)
//响应拦截器
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    // 错误处理
    alert(error);
    return Promise.reject(error);
  }
);

// 拦截器配置...  
export default axiosInstance

# pinia 状态管理

## 持久化
- npm install pinia-plugin-persistedstate 安装插件
- main.ts注册
  import { createPinia } from 'pinia'
  import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';

  //注册pinia 并使用持久化插件
  const pinia = createPinia();
  pinia.use(piniaPluginPersistedstate);
  app.use(pinia)
- 使用
  export const UserStore = defineStore('user', () => {
  const Token = ref('')
  
  function SetToken(token: string){
    Token.value = token
  }

  return { Token, SetToken }
  },{
    persist: true //启用持久化
  })

## 持久化-高级配置
可自定义存储方式、选择性存储

## /stores/userStore.ts 实例
import { ref } from 'vue'
import { defineStore } from 'pinia'

export const UserStore = defineStore('user', () => {
  const Token = ref('')
  
  function SetToken(token: string){
    Token.value = token
  }

  return { Token, SetToken }
},{
  persist: true //启用持久化
})

其他ts中使用：
import { UserStore } from '@/stores/userStore'
const userStore = UserStore()
const loginCode = ref('')
loginCode.value = userStore.Token
userStore.SetToken('1232')

# 父子组件props传参、emits回调事件

## 子组件
- 定义组件参数传参
const props = defineProps<{
        IsVisible: boolean
        AppInfo?: DataModels.App  // ?代表可选参数
    }>()

//如果定义了本地变量来接收参数 如果传递过来的是ref变量 则父组件改变值时 子组件变量不会更新
const _isVisible = props.IsVisible;
//使用计算属性 不定义本地变量接收, 父组件改变值时 子组件在使用计算属性时会获取到更新后的值
const _isVisible = computed(() => _props.IsVisible)

- 定义回调事件
const emits = defineEmits<{
        saveApp: [DataModels.App] //事件名称、参数列表
    }>()

emits('saveApp', appInfo.value) //触发事件

## 父组件
<template>
    <子组件 :IsVisible="true" @saveApp="handelSaveApp"></子组件>
</template>

<script setup lang="ts">
 const handelSaveApp = (appinfo: DataModels.App) => {
        appList.value.push(appinfo)
    }
</script>

v-model:IsVisible="_isVisible" 可简写成:IsVisible="true" 绑定ref参数 
@saveApp="handelSaveApp" 绑定事件，子组件触发事件会调用handelSaveApp函数 执行父组件的逻辑

# 组件暴露参数和方法defineExpose

## 子组件
const _isVisible = ref(false)

function OpenAndInitData(isVisible: boolean, appinfo: DataModels.App | null) {
      _isVisible.value = isVisible
      _appInfo.value = appinfo
      if(_appInfo.value != null){
          _title.value = '编辑应用信息'
          _appId.value = _appInfo.value.AppId
          _appName.value = _appInfo.value.AppName
          _isVisibleAppId.value = true
      }
      else{
          _title.value = '新增应用'
          _appId.value = 0;
          _appName.value = '';
          _isVisibleAppId.value = false
      }
  }

defineExpose({
      OpenAndInitData
  })

## 父组件
<script>
  const _updateDialog = ref<InstanceType<typeof AppUpdateDialog> | null>(null)
  const haha = () => {
    f(_updateDialog.value){
      console.log(_updateDialog.value._isVisible.value)
      _updateDialog.value.OpenAndInitData(true, null)
    }
  }
</script>
<template>
  <AppUpdateDialog ref="_updateDialog" @SaveApp="HandelSaveApp" @CloseDialog="HandleCloseDialog"></AppUpdateDialog>
</template>

# ref Html元素
const _htmlPassword = ref<HTMLInputElement | null>(null)
const _passWord = ref('')

<el-input class="input" ref="_htmlPassword" v-model="_passWord" type="password" show-password></el-input>