技能系统
[toc]

在Godot中构建一个基于组合架构的技能系统，意味着将技能拆分为可复用的功能单元，通过组合这些单元来创建复杂技能，而非依赖深层的继承关系。这种设计能带来更好的灵活性和可维护性。下面是一个核心的实现框架。

### 🔌 核心架构组件

一个典型的组合式技能系统包含以下几个核心组件，它们协同工作：

| 组件 | 说明 | 在Godot中的角色 |
| :--- | :--- | :--- |
| **AbilityComponent** | 技能系统的入口，挂载在可施放技能的角色上，管理所有技能实例。 | 节点（如 `Node`） |
| **Ability (技能)** | 定义技能的整体逻辑，如冷却、施放条件，但它不直接实现效果，而是协调**效果器**。 | 节点或资源（如 `Resource`） |
| **AbilityEffect (效果器)** | **组合的核心**。独立的、可重用的功能单元，如造成伤害、施加状态、生成物体。 | 节点或资源（如 `Resource`） |
| **EffectContext (效果上下文)** | 一个数据结构，在效果器间传递技能相关的运行时信息，如施放者、目标、技能等级等。 | 自定义类（如 `Class`） |

这种设计的精髓在于，`Ability` 本身不处理具体逻辑，而是作为一个**容器和协调者**，通过调用一系列 `AbilityEffect` 来完成技能效果。这正是组合优于继承思想的体现：技能的“能力”不再由它“是什么”（继承链）决定，而是由它“拥有什么”效果（组合）决定。

### 🧩 实现关键步骤

以下是实现该系统的主要步骤和代码要点。

#### 1. 定义效果器基类 (AbilityEffect)
首先，需要定义一个效果器基类，为所有具体效果提供统一接口。

```gdscript
# AbilityEffect.gd
class_name AbilityEffect
extends Resource

# 所有效果器需要实现的核心方法。
# context 参数包含了技能施放时的所有上下文信息。
func execute(context: EffectContext) -> void:
    pass
```

#### 2. 创建具体效果器 (Concrete Effects)
通过继承 `AbilityEffect`，可以创建各种独立的效果器。这些效果器是可配置和复用的“积木”。

```gdscript
# DamageEffect.gd
class_name DamageEffect
extends AbilityEffect

export var base_damage: float = 10.0

func execute(context: EffectContext) -> void:
    var final_damage = base_damage * context.skill_level
    # 假设目标对象有一个 take_damage 方法
    if context.target and context.target.has_method("take_damage"):
        context.target.take_damage(final_damage, context.caster)

# ApplyBuffEffect.gd
class_name ApplyBuffEffect
extends AbilityEffect

export var buff_resource: Resource # 指向一个定义Buff的Resource

func execute(context: EffectContext) -> void:
    if context.target and context.target.has_method("add_buff"):
        var new_buff = buff_resource.duplicate()
        context.target.add_buff(new_buff)
```

#### 3. 构建技能 (Ability)
技能本身成为一个效果器的列表管理器。

```gdscript
# Ability.gd
class_name Ability
extends Resource

export var display_name: String
export var cooldown: float = 1.0
export(Array, Resource) var effects: Array # 这里存放AbilityEffect资源引用

var is_ready: bool = true

# 主要的施放方法
func cast(context: EffectContext) -> void:
    if not is_ready:
        return
    
    is_ready = false
    # 启动冷却计时器...
    start_cooldown_timer()
    
    # 遍历并执行所有效果器！
    for effect in effects:
        if effect:
            effect.execute(context)
```

#### 4. 在场景中使用
最后，在角色场景中挂载 `AbilityComponent`，并在编辑器中配置技能。

1.  **角色场景结构**：
    ```
    Player (CharacterBody2D)
    ├── Sprite2D
    ├── CollisionShape2D
    └── AbilityComponent (节点)
        └── (技能实例会在运行时添加为其子节点或由它管理)
    ```

2.  **配置技能**：在Godot编辑器中，为 `Ability` 资源添加和配置效果器列表。例如，一个“火焰冲击”技能可以依次组合：`DamageEffect`、`ApplyBuffEffect`（施加灼烧）、`SpawnVFXEffect`（生成粒子特效）。

### 💡 组合架构的优势

- **高度灵活**：通过像搭积木一样组合效果器，可以快速创建新技能，无需编写新代码。
- **避免类爆炸**：无需为每个技能变体创建复杂的继承树，只需创建新的组合方式。
- **数据驱动**：策划或设计者可以通过编辑资源文件（如JSON或Godot的`.tres`资源）来调整技能，提高开发效率。
- **易于调试和测试**：每个效果器职责单一，可以独立测试。

### 🚀 进阶扩展方向

当基础系统搭建完成后，可以考虑以下扩展来增强其能力：

- **资源管理与消耗**：创建 `AbilityCost` 类，将其组合进技能，在施放前检查魔法值、体力等资源是否足够。
- **更复杂的目标选择**：实现不同的目标选择效果器（如扇形区域、直线、友方单位等），使技能的目标选择逻辑也模块化。
- **效果树与时序控制**：引入简单的时序概念，例如让效果器可以按顺序、并行或延迟执行，以支持更复杂的技能动画与效果联动。

希望这个基于组合架构的技能系统框架能为你提供一个坚实的起点。如果你在实现某个具体部分，比如效果器的交互或冷却管理时遇到问题，我们可以更深入地探讨。

您描述的这种架构非常精准，它是在基础组合架构上更进一步的**模块化设计**。这种设计将“效果定义”和“效果执行”分离，让系统的灵活性和可复用性达到新的高度。

下面这个表格清晰地展示了这种层级关系：

| 层级 | 角色 | 职责 | 示例 |
| :--- | :--- | :--- | :--- |
| **效果器** | **指挥官** | 定义技能的整体逻辑和规则，但不直接实现具体效果。 | 一个“火焰冲击”效果器，它决定“何时”、“以何种方式”触发伤害和点燃。 |
| **效果执行器** | **士兵** | 实现单一、具体的游戏功能，是可复用的“积木”。 | `DamageExecutor`（直接伤害执行器）、`PeriodicDamageExecutor`（周期伤害执行器）。 |



### 🎯 核心思想：职责分离

这种架构的核心优势在于**职责分离**：
- **效果器** 变得非常轻量，只关心**逻辑流程**，比如触发条件、目标选择、效果组合顺序。
- **效果执行器** 则专注于**功能实现**，每个执行器只做好一件事，成为高度可复用的工具。

### 🛠️ 如何用代码实现

让我们用Godot（GDScript）来具体实现您描述的“若直接伤害、周期伤害”的例子。

#### 1. 首先，定义效果执行器基类
这是所有具体执行器需要继承的契约。
```gdscript
# EffectExecutor.gd
class_name EffectExecutor
extends Resource

# 每个执行器需要实现的方法
# context: 包含施放者、目标、技能等级等信息的上下文对象
func execute(context: EffectContext) -> void:
    pass
```

#### 2. 实现具体的效果执行器
创建专注于单一功能的执行器。

```gdscript
# DamageExecutor.gd - 直接伤害执行器
class_name DamageExecutor
extends EffectExecutor

export var base_damage: float = 10.0
export var damage_type: String = "Physical"

func execute(context: EffectContext) -> void:
    var final_damage = base_damage * context.skill_level
    # 假设目标对象有一个 take_damage 方法
    if context.target and context.target.has_method("take_damage"):
        context.target.take_damage(final_damage, damage_type, context.caster)
```

```gdscript
# PeriodicDamageExecutor.gd - 周期伤害执行器
class_name PeriodicDamageExecutor
extends EffectExecutor

export var damage_per_tick: float = 5.0
export var tick_interval: float = 1.0
export var total_duration: float = 5.0

func execute(context: EffectContext) -> void:
    # 将周期伤害作为一个Buff或状态效果应用到目标身上
    var dot_buff = DamageOverTimeBuff.new()
    dot_buff.damage_per_tick = damage_per_tick
    dot_buff.tick_interval = tick_interval
    dot_buff.duration = total_duration
    dot_buff.caster = context.caster
    
    if context.target and context.target.has_method("add_buff"):
        context.target.add_buff(dot_buff)
```

#### 3. 构建高阶效果器
现在，效果器不再自己实现伤害，而是**持有**并**调用**这些执行器。

```gdscript
# FlameShockEffect.gd - 一个结合了直接伤害和周期伤害的效果器
class_name FlameShockEffect
extends AbilityEffect

# 通过导出变量，在Godot编辑器中直接分配执行器资源
export(Resource) var immediate_damage_executor
export(Resource) var periodic_damage_executor

func execute(context: EffectContext) -> void:
    # 1. 执行直接伤害
    if immediate_damage_executor:
        immediate_damage_executor.execute(context)
    
    # 2. 执行周期伤害（点燃效果）
    if periodic_damage_executor:
        periodic_damage_executor.execute(context)
```

#### 4. 在编辑器中组合
最关键的一步是在Godot编辑器中通过资源配置来组合技能，而无需写代码：
1.  创建两个 `DamageExecutor` 资源实例，分别配置为“火焰直接伤害”和“火焰持续伤害”。
2.  创建一个 `FlameShockEffect` 资源实例，将上面两个执行器资源拖拽到它的对应属性中。
3.  在一个 `Ability` 资源的效果列表里，添加这个 `FlameShockEffect`。

### 💡 这种架构的显著优势

- **极致的复用性**：`DamageExecutor` 可以被火球术、火焰冲击、火山术等任何需要造成伤害的效果器使用。你只需配置不同的伤害值和类型。
- **高度灵活性**：策划或设计师可以在编辑器中像搭乐高一样，将不同的执行器（伤害、治疗、位移、施加Buff）组合成全新的效果器，快速迭代技能设计。
- **易于维护**：如果需要修改所有物理伤害的计算公式，你只需要改动 `DamageExecutor` 这一个文件。

这种“效果器 + 多个执行器”的设计，是组合思想在游戏开发中更深层次的运用，它让代码真正实现了“数据驱动”，极大地提升了开发效率和系统的健壮性。希望这个解释对您有启发！


在组合式技能系统的基础上，集成一个同样基于组合架构的Buff系统，可以创建出高度灵活且强大的游戏战斗框架。下面是如何设计和实现这样一个Buff系统。

### 💡 Buff系统的核心设计思路

Buff系统的核心与技能系统一脉相承：**将Buff的效果（Effect）与Buff的载体（Container）分离**。一个Buff本身不实现具体逻辑，而是作为容器，管理其生命周期（如持续时间、层数），并持有多个“效果器”来定义其具体行为。

| 组件 | 说明 | 在Godot中的角色 |
| :--- | :--- | :--- |
| **BuffContainer** | 挂载在角色身上，管理所有当前生效的Buff，负责统一更新和生命周期管理。 | 节点（如 `Node`） |
| **BuffInstance** | 单个Buff的实例，包含元数据（如持续时间、层数、施加者）和其携带的效果器列表。 | 资源（如 `Resource`）或节点 |
| **BuffEffect** | **效果器**，实现具体的Buff逻辑，如修改属性、造成伤害、施加状态等。与技能效果器可共用基类。 | 资源（如 `Resource`） |
| **BuffContext** | 传递Buff相关的运行时信息，如施加者、目标、技能来源等。 | 自定义类（如 `Class`） |

这种设计的精髓在于，`BuffInstance` 只负责 **“是什么”**（持续时间、层数），而 `BuffEffect` 负责 **“做什么”**（具体效果）。通过组合不同的效果器，可以轻松创造出复杂的Buff，而无需创建庞大的继承体系。

### 🧠 Buff的生命周期与关键特性

一个健壮的Buff系统需要清晰的生命周期和丰富的特性来控制游戏逻辑。

1.  **生命周期回调**：Buff在其生命周期的关键节点会触发事件，允许效果器执行相应逻辑。
    *   `on_apply`：当Buff被成功添加到目标时触发。
    *   `on_interval`：按固定间隔触发，用于实现持续伤害（DOT）或治疗（HOT）。
    *   `on_remove`：当Buff因时间到期、被驱散等原因移除时触发。
    *   `on_refresh`：当同类型Buff叠加或刷新时触发。

2.  **层数与持续时间管理**：Buff通常支持叠加层数，并有不同的叠加策略（如刷新时间、增加层数）。`BuffContainer` 需要统一管理所有Buff的计时和层数更新。

3.  **状态修改**：某些Buff会改变角色的状态，如眩晕、沉默、无敌等。这些状态是高度抽象的，应该与具体的动画或运动逻辑解耦。`BuffContainer` 可以汇总所有Buff的状态效果，提供一个统一的查询接口给其他系统（如移动系统、技能系统）。

4.  **事件监听与响应**：高级Buff需要能监听游戏内的事件并做出响应。例如，一个Buff可以在角色受到伤害时触发反击效果。这可以通过Godot的信号系统实现，让 `BuffContainer` 转发相关事件给感兴趣的Buff效果器。

### 🛠️ 实现步骤与代码框架

以下是在Godot中实现该系统的关键步骤和代码要点。

#### 1. 定义基础效果器 (BuffEffect)

效果器是组合的核心，可以与技能系统的效果器共用基类或接口。

```gdscript
# BuffEffect.gd
class_name BuffEffect
extends Resource

# 所有效果器需要实现的方法
func on_apply(buff: BuffInstance, target: Node) -> void:
    pass

func on_interval(buff: BuffInstance, target: Node) -> void:
    pass

func on_remove(buff: BuffInstance, target: Node) -> void:
    pass

# 也可以在这里定义事件监听方法，如 on_take_damage
```

#### 2. 实现具体的效果器

创建可复用的效果器，例如修改属性和造成周期性伤害。

```gdscript
# ModifyAttributeEffect.gd
class_name ModifyAttributeEffect
extends BuffEffect

export var attribute_name: String # 例如 "attack_power"
export var modifier_type: String # 例如 "ADD" 或 "MULTIPLY"
export var value: float

func on_apply(buff: BuffInstance, target: Node) -> void:
    if target.has_method("modify_attribute"):
        target.modify_attribute(attribute_name, modifier_type, value, buff)

func on_remove(buff: BuffInstance, target: Node) -> void:
    if target.has_method("unmodify_attribute"):
        target.unmodify_attribute(attribute_name, modifier_type, value, buff)

# PeriodicDamageEffect.gd
class_name PeriodicDamageEffect
extends BuffEffect

export var damage_per_tick: float

func on_interval(buff: BuffInstance, target: Node) -> void:
    if target.has_method("take_damage"):
        var damage_context = DamageContext.new()
        damage_context.amount = damage_per_tick * buff.get_stack_count() # 根据层数计算
        damage_context.source = buff.caster
        target.take_damage(damage_context)
```

#### 3. 构建Buff实例 (BuffInstance)

`BuffInstance` 作为容器，持有效果器列表并管理自身状态。

```gdscript
# BuffInstance.gd
class_name BuffInstance
extends Resource

export var display_name: String
export var duration: float = 5.0
export var max_stacks: int = 1
export var is_permanent: bool = false
export(Array, Resource) var effects: Array # 存放BuffEffect资源

var stack_count: int = 1
var elapsed_time: float = 0.0
var caster: Node = null

func setup(_caster: Node) -> void:
    caster = _caster

func get_stack_count() -> int:
    return stack_count

func is_expired() -> bool:
    return not is_permanent and elapsed_time >= duration

# 由BuffContainer调用更新
func process(delta: float, target: Node) -> void:
    if not is_permanent:
        elapsed_time += delta
```

#### 4. 创建Buff容器 (BuffContainer)

这是系统的核心管理器，挂载在每个可接受Buff的角色身上。

```gdscript
# BuffContainer.gd
class_name BuffContainer
extends Node

var active_buffs: Dictionary = {} # Key: Buff资源ID, Value: BuffInstance

func _process(delta: float) -> void:
    # 遍历所有Buff并更新，检查是否过期
    for buff_id in active_buffs.keys():
        var buff_instance: BuffInstance = active_buffs[buff_id]
        buff_instance.process(delta, get_parent())
        
        if buff_instance.is_expired():
            remove_buff(buff_id)

func apply_buff(buff_resource: BuffInstance, caster: Node) -> void:
    var buff_id = buff_resource.resource_path
    if active_buffs.has(buff_id):
        # 已存在同类型Buff，执行刷新/叠加逻辑
        var existing_buff = active_buffs[buff_id]
        if existing_buff.max_stacks > 1:
            existing_buff.stack_count = min(existing_buff.stack_count + 1, existing_buff.max_stacks)
        existing_buff.elapsed_time = 0.0 # 刷新持续时间
        # 触发效果器的 on_refresh 逻辑...
    else:
        # 新Buff
        var new_buff = buff_resource.duplicate()
        new_buff.setup(caster)
        active_buffs[buff_id] = new_buff
        # 触发效果器的 on_apply 逻辑...
        for effect in new_buff.effects:
            if effect:
                effect.on_apply(new_buff, get_parent())

func remove_buff(buff_id: String) -> void:
    if active_buffs.has(buff_id):
        var buff_instance = active_buffs[buff_id]
        # 触发效果器的 on_remove 逻辑...
        for effect in buff_instance.effects:
            if effect:
                effect.on_remove(buff_instance, get_parent())
        active_buffs.erase(buff_id)
```

#### 5. 与技能系统集成

技能的效果器可以轻松地施加Buff，实现两个系统的无缝衔接。

```gdscript
# 一个技能效果器，用于施加Buff
class_name ApplyBuffEffect
extends AbilityEffect # 注意，它继承自技能系统的效果器

export var buff_resource: BuffInstance

func execute(context: EffectContext) -> void:
    if context.target and context.target.has_node("BuffContainer"):
        var buff_container: BuffContainer = context.target.get_node("BuffContainer")
        buff_container.apply_buff(buff_resource, context.caster)
```

### 💎 进阶设计：状态与事件机制

对于更复杂的互动（如“受到控制效果时触发”），可以引入基于标签（Tag）的状态和事件机制。

- **Buff标签**：为每个Buff打上标签（如 `FIRE`, `STUN`, `DOT`）。
- **状态查询**：`BuffContainer` 可以提供接口供其他系统查询当前角色是否处于某种状态（如 `is_affected_by_tag("STUN")`）。
- **事件转发**：让 `BuffContainer` 监听角色的受伤、死亡等事件，并将其转发给所有活跃的Buff效果器，由效果器决定是否响应。

这套基于组合架构的Buff系统，与你的技能系统理念一致，提供了极高的灵活性和可扩展性。通过将效果分解为可配置的模块，策划人员甚至可以在编辑器中像搭积木一样设计和调整Buff，极大地提升了开发效率。

希望这个详细的方案能帮助你构建出理想中的战斗系统！如果你对某个具体细节（如状态机的实现或事件系统）有更深入的兴趣，我们可以继续探讨。



在基于组合架构的技能与Buff系统中，`EffectContext`（效果上下文）的设计至关重要。它作为一个**数据载体**，在技能施放或效果应用的整个生命周期中，传递所有相关的运行时信息。

### 💡 核心设计理念

`EffectContext` 的核心任务是**解耦**。技能逻辑（例如一个火球术）不直接依赖具体的施放者或目标对象，而是通过 `EffectContext` 获取所需信息。这使得同一个技能逻辑可以被不同的角色复用，极大地提升了系统的灵活性。

一个健壮的 `EffectContext` 通常包含以下几类信息：

| 信息类别 | 说明 | 示例 |
| :--- | :--- | :--- |
| **来源信息** | 效果发起者的相关数据。 | 施放者对象、技能等级、属性值（如法术强度）。 |
| **目标信息** | 效果承受者的相关数据。 | 目标对象、目标位置、目标身上的其他效果。 |
| **技能信息** | 本次效果触发的来源信息。 | 触发的技能实例、技能配置数据（如基础伤害）。 |
| **随机种子** | 用于保证随机结果在客户端和服务器间同步。 | 一个确定的随机数种子，用于计算暴击、伤害浮动。 |
| **自定义数据** | 用于在复杂的效果链中传递临时信息。 | 一个字典（Dictionary）结构，存放任意键值对。 |

### 🛠️ Godot 实现方案

在Godot中，`EffectContext` 可以设计为一个可扩展的引用类（`Reference`），以便在多个效果器之间高效传递。

#### 1. 基础类设计

```gdscript
# EffectContext.gd
class_name EffectContext
extends Reference

# 来源信息
var source: Node = null           # 施放者节点（如角色）
var source_ability: Ability = null # 触发的技能实例
var skill_level: int = 1          # 技能等级
var source_stats: Dictionary = {} # 施放者的属性快照（如攻击力、法术强度）

# 目标信息
var target: Node = null          # 主要目标节点
var target_point: Vector3 = Vector3.ZERO # 目标位置（对于范围技能）
var targets: Array = []          # 多个目标（对于AOE技能）

# 环境与随机性
var random_seed: int = 0         # 用于同步的随机种子
var rng: RandomNumberGenerator = null # 基于种子的RNG实例

# 自定义数据袋，用于效果器间传递临时信息
var custom_data: Dictionary = {}

func _init(seed_value: int = 0):
    random_seed = seed_value
    if random_seed != 0:
        rng = RandomNumberGenerator.new()
        rng.seed = random_seed

# 提供一个便捷方法，基于上下文种子获取随机数
func get_random_float() -> float:
    if rng:
        return rng.randf()
    return randf()
```

#### 2. 在技能系统中传递

技能（`Ability`）在施放时创建 `EffectContext`，并填充初始数据，然后将其传递给所有效果器（`AbilityEffect`）。

```gdscript
# Ability.gd
func cast(caster: Node, target: Node, target_point: Vector3 = Vector3.ZERO) -> void:
    # 1. 创建效果上下文
    var context = EffectContext.new(generate_deterministic_seed())
    
    # 2. 填充上下文信息
    context.source = caster
    context.source_ability = self
    context.skill_level = get_current_level(caster)
    context.source_stats = caster.get_current_stats_snapshot() # 获取属性快照
    
    context.target = target
    context.target_point = target_point
    
    # 3. 遍历并执行所有效果器，传递上下文
    for effect in effects:
        if effect:
            effect.execute(context)
```

#### 3. 效果器使用上下文

效果器（如伤害计算器）从 `EffectContext` 中获取所需数据来执行逻辑。

```gdscript
# DamageEffect.gd
class_name DamageEffect
extends AbilityEffect

export var base_damage: float = 10.0
export var damage_scale_factor: String = "attack_power" # 指定缩放属性

func execute(context: EffectContext) -> void:
    if not context.target:
        return
    
    # 从上下文中获取技能等级和施放者属性
    var level = context.skill_level
    var scaling_value = context.source_stats.get(damage_scale_factor, 0.0)
    
    # 计算最终伤害（可以加入随机浮动）
    var final_damage = base_damage * level + scaling_value
    final_damage *= (0.9 + context.get_random_float() * 0.2) # 90%-110%的伤害浮动
    
    # 调用目标对象的受伤方法
    if context.target.has_method("take_damage"):
        context.target.take_damage(final_damage, context.source)
```

#### 4. 在Buff系统中传递

Buff系统同样可以利用 `EffectContext`。当技能效果器施加一个Buff时，可以将技能上下文信息传递给Buff实例。

```gdscript
# ApplyBuffEffect.gd
class_name ApplyBuffEffect
extends AbilityEffect

export var buff_resource: BuffInstance

func execute(context: EffectContext) -> void:
    if context.target and context.target.has_node("BuffContainer"):
        var buff_container: BuffContainer = context.target.get_node("BuffContainer")
        var buff_instance = buff_resource.duplicate()
        
        # 将上下文中的施放者信息传递给Buff
        buff_instance.caster = context.source
        # 也可以将整个上下文或部分数据存入Buff，供其效果器使用
        buff_instance.source_context = context
        
        buff_container.apply_buff(buff_instance)
```

### 💎 进阶设计：上下文继承与扩展

对于复杂技能（如召唤物继承施放者属性），可以考虑**上下文继承**机制。

```gdscript
# 在 EffectContext 类中添加方法
func create_child_context() -> EffectContext:
    var child = EffectContext.new(self.random_seed)
    # 复制当前上下文的大部分数据
    child.source = self.source
    child.source_stats = self.source_stats.duplicate()
    child.skill_level = self.skill_level
    # 但目标和技能信息可以重置
    return child

# 使用场景：一个召唤技能的效果器
func execute(context: EffectContext) -> void:
    var summon = spawn_summon()
    # 为召唤物创建一个新的上下文，继承施放者属性
    var summon_context = context.create_child_context()
    summon_context.source = summon # 新的“施放者”是召唤物本身
    # 召唤物施放的技能可以基于这个新上下文
```

### ⚠️ 注意事项

- **网络同步**：如果游戏需要网络同步，务必确保 `EffectContext` 中的关键数据（如随机种子、技能等级）在客户端和服务器上一致。
- **性能**：避免在 `EffectContext` 中存储过大的数据（如完整的角色数据），尽量只保存必要的快照或引用。
- **生命周期**：明确 `EffectContext` 的生命周期，它通常只存在于一次技能施放或效果应用的过程中，不应长期持有。

通过精心设计的 `EffectContext` 类，你的技能和Buff系统各组件将能够在一个解耦、类型安全（通过Godot的导出变量和字典键约定）的环境中高效协作，为构建复杂多变的游戏玩法打下坚实基础。